#include <jni.h>
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <android/Log.h>
#include <vector>

// for native audio
#include <SLES/OpenSLES.h>
#include <SLES/OpenSLES_Android.h>

#ifdef __cplusplus
extern "C" {
#endif
/* Class:     com_example_hellojni_HelloJni
 * Method:    stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
SLObjectItf aud; SLEngineItf aud_eng; SLObjectItf aud_mix; SLObjectItf aud_player; SLPlayItf player_ctrl; SLBufferQueueItf aud_buf;// 声音引擎的对象介面  声音引擎  混音器对象介面 播放器对象


void AudioEngine::_newsnd_cb(SLBufferQueueItf bq, void *context){
	//(*bq)->Enqueue(bq, snd, sndlen); /* 操作缓冲区队列介面，将长度为 sndlen的声音数据snd排进队列 */
	// phdr->dwBufferLength = mwaveformat.nAvgBytesPerSec / blockps
	AudioEngine* eng = (AudioEngine*)context; int8_t* a; int32_t retry = 6000, buflen = 8000 * 16 / eng->getblockps();
	a = eng->pop(buflen);
	while (a == NULL && !xiny120::gtmvreader::me()->getbreaknow() && retry >= 0 && !eng->breaknow){ App::Sleep(10); retry--; a = eng->pop(buflen); }
	if (a != NULL) { // len == 0 表示结束。
		(*bq)->Enqueue(bq, a, buflen);
		//if ((!eng->waveoutreset) && (res = waveOutWrite(hWave, hdr, sizeof(*hdr))) != MMSYSERR_NOERROR){ //}
		eng->mstart += (UNITS / eng->getblockps() * eng->getspeed());
	}else{ // 尝试100次都失败的话，只能说结束了。
		a = eng->poplast(buflen);
		(*bq)->Enqueue(bq, a, buflen);
		//memcpy(hdr->lpData, a, hdr->dwBufferLength);
		//if ((!eng->waveoutreset) && (res = waveOutWrite(hWave, hdr, sizeof(*hdr))) != MMSYSERR_NOERROR){
		//}
		delete[] a;
	}
}

bool AudioEngine::start(const float& speed, const int32_t& sps, const int32_t& bps, const int32_t& ch, const int32_t& f){
	mstart = 0; if (mopen) stop();
	mspeed = speed; breaknow = false;
	SLresult r;	SLInterfaceID effect[1] = {SL_IID_ENVIRONMENTALREVERB}; SLboolean effect_bool[1] = {SL_BOOLEAN_FALSE}; // 音效 音效强制实现逻辑
	if((r = slCreateEngine(&aud, 0, NULL, 0, NULL, NULL)) == SL_RESULT_SUCCESS){ //首先我们创建声音引擎的对象介面 ：
		if((r = (*aud)->Realize(aud, SL_BOOLEAN_FALSE)) == SL_RESULT_SUCCESS){ // 通过_aud的Realize子函数实现声音引擎的对象介面
			if((r = (*aud)->GetInterface(aud, SL_IID_ENGINE, &aud_eng)) == SL_RESULT_SUCCESS){
				if((r = (*aud_eng)->CreateOutputMix(aud_eng, &aud_mix, 1, effect, effect_bool)) == SL_RESULT_SUCCESS){// 通过声音引擎创建输出混音器对象，并且非强制性的开启环境混响效果
					if((r = (*aud_mix)->Realize(aud_mix, SL_BOOLEAN_FALSE)) == SL_RESULT_SUCCESS){// 实现混音器对象
						//SLInterfaceID ids[] = { SL_IID_BUFFERQUEUE, SL_IID_EFFECTSEND, SL_IID_VOLUME };// 播放器功能列表  缓冲区队列功能 音效功能 音量功能
						//SLboolean req[] = {SL_BOOLEAN_TRUE,SL_BOOLEAN_TRUE,SL_BOOLEAN_TRUE}; // 强制实现id中对应的 缓冲区队列功能   强制实现id中对应的 音效功能   强制实现id中对应的 音量功能
						SLInterfaceID ids[] = { SL_IID_BUFFERQUEUE};// 播放器功能列表  缓冲区队列功能 音效功能 音量功能
						SLboolean req[] = {SL_BOOLEAN_TRUE}; // 强制实现id中对应的 缓冲区队列功能   强制实现id中对应的 音效功能   强制实现id中对应的 音量功能
						SLDataLocator_BufferQueue loc_bufq = {SL_DATALOCATOR_BUFFERQUEUE, SLuint32(getblockps())};
					    SLDataFormat_PCM format_pcm;
					    format_pcm.formatType = SL_DATAFORMAT_PCM; format_pcm.numChannels = 1;
					    format_pcm.samplesPerSec = SL_SAMPLINGRATE_8;
					    format_pcm.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;
					    format_pcm.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;
				        format_pcm.channelMask = SL_SPEAKER_FRONT_CENTER;
					    format_pcm.endianness = SL_BYTEORDER_LITTLEENDIAN;
					    SLDataSource audioSrc = {&loc_bufq, &format_pcm};
					    SLDataLocator_OutputMix loc_outmix = {SL_DATALOCATOR_OUTPUTMIX, NULL};
					    SLDataSink audioSnk = {&loc_outmix, NULL};
						if((r = (*aud_eng)->CreateAudioPlayer(aud_eng, &aud_player, &audioSrc, &audioSnk, 1, ids, req)) == SL_RESULT_SUCCESS){
							if(( r = (*aud_player)->Realize(aud_player, SL_BOOLEAN_FALSE)) == SL_RESULT_SUCCESS){ //实现声音播放器对象
								if(( r = (*aud_player)->GetInterface(aud_player, SL_IID_PLAY, &player_ctrl)) == SL_RESULT_SUCCESS){ //获得播放控制器
									if(( r = (*aud_player)->GetInterface(aud_player, SL_IID_BUFFERQUEUE, &aud_buf)) == SL_RESULT_SUCCESS){ //获得缓冲区介面
										if(( r = (*aud_buf)->RegisterCallback(aud_buf, AudioEngine::_newsnd_cb, this)) == SL_RESULT_SUCCESS){
											mopen = true; mpause = false; play();
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

bool AudioEngine::play(){
	SLresult r; mstart = 0; bool ret = true,first = true; int8_t* a; int32_t hdrcount = 1000 / blockps, i, retry;
	if (!mopen) return false;
	r = (*player_ctrl)->SetPlayState(player_ctrl, SL_PLAYSTATE_PLAYING );
	if(SL_RESULT_SUCCESS == r){
		ret = true;
	}else ret = false;
	return ret;
}


JNIEXPORT void JNICALL Java_com_chidacan_jnitest_MainActivity_testjni (JNIEnv *, jobject){
	__android_log_print(ANDROID_LOG_INFO,"test","test0199999999999999999999999");
	std::vector<int64_t> all;
	int64_t t1 = 1400000085;
	all.push_back(t1);
	__android_log_print(ANDROID_LOG_INFO,"test","test0188888888888888888888888888888");
}

#ifdef __cplusplus
}
#endif
